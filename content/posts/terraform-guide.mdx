---
title: "Terraform expliqu√© simplement : Infrastructure as Code en 15 minutes"
description: "Comprends Terraform facilement et d√©ploie ta premi√®re infrastructure cloud. Guide complet pour d√©butants avec exemples pratiques et commandes essentielles."
date: "2025-02-05"
category: "devops"
tags: ["terraform", "iac", "devops", "cloud", "d√©butant"]
author: "BiLearn"
youtubeId: "dQw4w9WgXcQ"
---

## Sommaire

- [Introduction](#introduction)
- [C'est quoi Terraform ?](#cest-quoi-terraform)
- [Infrastructure as Code : Le concept](#infrastructure-as-code--le-concept)
- [Terraform vs autres outils](#terraform-vs-autres-outils)
- [Pourquoi utiliser Terraform ?](#pourquoi-utiliser-terraform)
- [Installation](#installation)
- [Ton premier d√©ploiement](#ton-premier-d√©ploiement)
- [Les commandes essentielles](#les-commandes-essentielles)
- [Comprendre les fichiers Terraform](#comprendre-les-fichiers-terraform)
- [Les Providers](#les-providers)
- [Les Resources](#les-resources)
- [Les Variables](#les-variables)
- [Les Outputs](#les-outputs)
- [Les Modules](#les-modules)
- [Le State : Le cerveau de Terraform](#le-state--le-cerveau-de-terraform)
- [Exemple pratique : D√©ployer sur AWS](#exemple-pratique--d√©ployer-sur-aws)
- [Exemple complet : Infrastructure web](#exemple-complet--infrastructure-web)
- [Bonnes pratiques](#bonnes-pratiques)
- [Commandes avanc√©es](#commandes-avanc√©es)
- [Exercice pratique](#exercice-pratique)
- [Prochaines √©tapes](#prochaines-√©tapes)
- [Ressources](#ressources)

## Introduction

**Terraform** est l'outil de r√©f√©rence pour g√©rer ton infrastructure cloud comme du code. 
Mais c'est quoi exactement ? Et pourquoi tout le monde l'utilise ? ‚òÅÔ∏è

Dans ce guide, je vais t'expliquer Terraform de mani√®re simple, avec des analogies concr√®tes 
et des exemples pratiques que tu pourras tester imm√©diatement.

## ü§î C'est quoi Terraform ?

Imagine que tu veux construire une maison. Tu as deux options :

### Option 1 : √Ä la main (l'ancien monde)
- Tu cliques partout dans la console AWS/Azure/GCP
- Tu oublies ce que tu as cr√©√©
- Impossible de recr√©er la m√™me chose facilement
- En cas d'erreur, tu ne sais plus o√π tu en es üò¢

### Option 2 : Avec un plan (Terraform)
- Tu √©cris le plan de ta maison dans un fichier
- Le plan est versionn√© dans Git
- Tu peux reconstruire la m√™me maison 1000 fois
- Si quelque chose casse, tu restaures depuis le plan ‚úÖ

**Terraform fait la m√™me chose avec ton infrastructure** : il transforme tes clics dans la console 
en **code versionn√©, reproductible et automatisable**.

## üìù Infrastructure as Code : Le concept

### Sans IaC
```
D√©veloppeur: "Je veux un serveur web"
Admin: *clique dans la console pendant 30 min*
Admin: "C'est fait... je crois... ü§î"
[6 mois plus tard]
D√©veloppeur: "Comment on a configur√© ce serveur d√©j√†?"
Admin: "Aucune id√©e... üòÖ"
```

### Avec Terraform (IaC)
```hcl
# main.tf
resource "aws_instance" "web" {
  ami           = "ami-12345678"
  instance_type = "t2.micro"
  
  tags = {
    Name = "Mon serveur web"
  }
}
```

**R√©sultat** : 
- ‚úÖ Reproductible
- ‚úÖ Versionn√© dans Git
- ‚úÖ Document√© automatiquement
- ‚úÖ Testable
- ‚úÖ Collaboratif

## üÜö Terraform vs autres outils

| Outil | Type | Utilisation |
|-------|------|-------------|
| **Terraform** | IaC d√©claratif | Provisionner infrastructure |
| Ansible | Configuration Management | Configurer des serveurs |
| CloudFormation | IaC AWS uniquement | Infrastructure AWS |
| Pulumi | IaC avec vrais langages | Infrastructure (TypeScript, Python...) |
| ARM Templates | IaC Azure uniquement | Infrastructure Azure |

**Avantage Terraform** : Fonctionne avec **tous les clouds** (AWS, Azure, GCP, DigitalOcean...) 
et des centaines de services (GitHub, Cloudflare, DataDog...) üöÄ

## üéØ Pourquoi utiliser Terraform ?

### ‚úÖ Les avantages

1. **Multi-cloud** : Un seul outil pour AWS, Azure, GCP et +3000 providers
2. **D√©claratif** : Tu d√©cris ce que tu veux, pas comment le faire
3. **Plan** : Terraform te montre ce qu'il va faire avant de le faire
4. **State Management** : Terraform sait ce qui existe d√©j√†
5. **Modules** : R√©utilise des configurations
6. **Immutabilit√©** : Infrastructure pr√©visible et stable
7. **Community** : √ânorme √©cosyst√®me et registry de modules

### ‚ùå Les inconv√©nients

- Courbe d'apprentissage au d√©but
- Le state peut √™tre d√©licat √† g√©rer
- N√©cessite de comprendre les APIs cloud
- Peut √™tre lent sur de grosses infrastructures

> **Mon avis** : Terraform a transform√© ma fa√ßon de g√©rer l'infrastructure. 
> C'est devenu aussi naturel que Git pour le code !

## üì• Installation

### Sur Linux/macOS

```bash
# Avec Homebrew (macOS/Linux)
brew tap hashicorp/tap
brew install hashicorp/tap/terraform

# Ou t√©l√©chargement direct
wget https://releases.hashicorp.com/terraform/1.7.0/terraform_1.7.0_linux_amd64.zip
unzip terraform_1.7.0_linux_amd64.zip
sudo mv terraform /usr/local/bin/
```

### Sur Windows

```powershell
# Avec Chocolatey
choco install terraform

# Ou t√©l√©charge depuis https://www.terraform.io/downloads
```

### V√©rification

```bash
terraform version
# Terraform v1.7.0
```

Si tu vois la version, c'est bon ! ‚úÖ

## üöÄ Ton premier d√©ploiement

Cr√©ons notre premier fichier Terraform pour d√©ployer un fichier local :

### √âtape 1 : Cr√©e un fichier main.tf

```hcl
# main.tf
terraform {
  required_version = ">= 1.0"
}

# Provider local (pas besoin de cloud pour tester)
provider "local" {}

# Cr√©e un fichier
resource "local_file" "hello" {
  filename = "hello.txt"
  content  = "Hello Terraform! üöÄ"
}
```

### √âtape 2 : Initialise Terraform

```bash
terraform init
```

Cette commande :
- ‚úÖ T√©l√©charge les providers n√©cessaires
- ‚úÖ Initialise le backend
- ‚úÖ Pr√©pare l'environnement

### √âtape 3 : Planifie les changements

```bash
terraform plan
```

Terraform te montre ce qu'il va cr√©er. C'est le **dry-run** !

### √âtape 4 : Applique les changements

```bash
terraform apply
```

Tape `yes` et... **magic !** üéâ

Le fichier `hello.txt` est cr√©√© ! V√©rifie avec :

```bash
cat hello.txt
# Hello Terraform! üöÄ
```

### √âtape 5 : D√©truis tout

```bash
terraform destroy
```

Le fichier est supprim√©. C'est aussi simple que √ßa !

## üé® Les commandes essentielles

```bash
# Initialiser un projet
terraform init

# Formater le code
terraform fmt

# Valider la syntaxe
terraform validate

# Voir le plan d'ex√©cution
terraform plan

# Appliquer les changements
terraform apply

# Appliquer sans confirmation
terraform apply -auto-approve

# D√©truire l'infrastructure
terraform destroy

# Afficher les outputs
terraform output

# Afficher le state
terraform show

# Lister les ressources
terraform state list

# Importer une ressource existante
terraform import <ressource> <id>

# Rafra√Æchir le state
terraform refresh

# Workspace (environnements)
terraform workspace list
terraform workspace new dev
terraform workspace select prod
```

## üìÅ Comprendre les fichiers Terraform

Structure typique d'un projet :

```
mon-projet/
‚îú‚îÄ‚îÄ main.tf           # Ressources principales
‚îú‚îÄ‚îÄ variables.tf      # D√©claration des variables
‚îú‚îÄ‚îÄ outputs.tf        # Outputs (valeurs de sortie)
‚îú‚îÄ‚îÄ providers.tf      # Configuration des providers
‚îú‚îÄ‚îÄ terraform.tfvars  # Valeurs des variables
‚îú‚îÄ‚îÄ versions.tf       # Versions requises
‚îî‚îÄ‚îÄ modules/          # Modules r√©utilisables
    ‚îî‚îÄ‚îÄ network/
        ‚îú‚îÄ‚îÄ main.tf
        ‚îú‚îÄ‚îÄ variables.tf
        ‚îî‚îÄ‚îÄ outputs.tf
```

## üîå Les Providers

Les providers sont les **plugins** qui permettent √† Terraform de communiquer avec les APIs.

```hcl
# providers.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "aws" {
  region = "eu-west-1"
}

provider "azurerm" {
  features {}
}
```

Providers populaires :
- AWS, Azure, GCP
- Kubernetes, Docker
- GitHub, GitLab
- Cloudflare, DataDog
- PostgreSQL, MySQL
- Et +3000 autres !

## üèóÔ∏è Les Resources

Les ressources sont les **√©l√©ments** que tu cr√©es.

```hcl
# Syntaxe g√©n√©rale
resource "<TYPE>" "<NOM>" {
  # Configuration
}

# Exemple : Serveur EC2 sur AWS
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  
  tags = {
    Name        = "Mon serveur web"
    Environment = "Production"
  }
}

# Exemple : Bucket S3
resource "aws_s3_bucket" "data" {
  bucket = "mon-super-bucket-2024"
  
  tags = {
    Name = "Bucket de donn√©es"
  }
}

# R√©f√©rencer une ressource dans une autre
resource "aws_s3_bucket_acl" "data_acl" {
  bucket = aws_s3_bucket.data.id  # ‚Üê R√©f√©rence
  acl    = "private"
}
```

## üìä Les Variables

Les variables rendent ton code **r√©utilisable**.

### D√©claration (variables.tf)

```hcl
# Variable simple
variable "region" {
  description = "R√©gion AWS"
  type        = string
  default     = "eu-west-1"
}

# Variable avec validation
variable "instance_type" {
  description = "Type d'instance EC2"
  type        = string
  default     = "t2.micro"
  
  validation {
    condition     = contains(["t2.micro", "t2.small"], var.instance_type)
    error_message = "Seuls t2.micro et t2.small sont autoris√©s."
  }
}

# Variable liste
variable "availability_zones" {
  description = "Zones de disponibilit√©"
  type        = list(string)
  default     = ["eu-west-1a", "eu-west-1b"]
}

# Variable map
variable "tags" {
  description = "Tags communs"
  type        = map(string)
  default = {
    Environment = "dev"
    ManagedBy   = "Terraform"
  }
}

# Variable sensible
variable "db_password" {
  description = "Mot de passe de la base de donn√©es"
  type        = string
  sensitive   = true
}
```

### Utilisation (main.tf)

```hcl
resource "aws_instance" "web" {
  ami               = "ami-12345678"
  instance_type     = var.instance_type  # ‚Üê Utilisation
  availability_zone = var.availability_zones[0]
  
  tags = merge(
    var.tags,
    {
      Name = "Web Server"
    }
  )
}
```

### Valeurs (terraform.tfvars)

```hcl
region            = "eu-west-3"
instance_type     = "t2.small"
availability_zones = ["eu-west-3a", "eu-west-3b", "eu-west-3c"]

tags = {
  Environment = "production"
  ManagedBy   = "Terraform"
  Team        = "DevOps"
}
```

### Autres fa√ßons de passer des variables

```bash
# Via ligne de commande
terraform apply -var="region=us-east-1"

# Via fichier
terraform apply -var-file="prod.tfvars"

# Via variable d'environnement
export TF_VAR_region="us-east-1"
terraform apply
```

## üì§ Les Outputs

Les outputs affichent des **informations** apr√®s le d√©ploiement.

```hcl
# outputs.tf
output "instance_ip" {
  description = "IP publique du serveur"
  value       = aws_instance.web.public_ip
}

output "instance_id" {
  description = "ID de l'instance"
  value       = aws_instance.web.id
}

output "bucket_name" {
  description = "Nom du bucket S3"
  value       = aws_s3_bucket.data.bucket
}

output "db_password" {
  description = "Mot de passe DB"
  value       = var.db_password
  sensitive   = true  # Cach√© par d√©faut
}
```

Afficher les outputs :

```bash
terraform output
# instance_ip = "54.123.45.67"
# instance_id = "i-0123456789abcdef"

terraform output instance_ip
# 54.123.45.67

terraform output -json
# JSON de tous les outputs
```

## üì¶ Les Modules

Les modules permettent de **r√©utiliser** des configurations.

### Structure d'un module

```
modules/
‚îî‚îÄ‚îÄ ec2-instance/
    ‚îú‚îÄ‚îÄ main.tf
    ‚îú‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ outputs.tf
    ‚îî‚îÄ‚îÄ README.md
```

### Cr√©er un module (modules/ec2-instance/main.tf)

```hcl
variable "instance_name" {
  type = string
}

variable "instance_type" {
  type    = string
  default = "t2.micro"
}

resource "aws_instance" "this" {
  ami           = "ami-12345678"
  instance_type = var.instance_type
  
  tags = {
    Name = var.instance_name
  }
}

output "instance_id" {
  value = aws_instance.this.id
}

output "public_ip" {
  value = aws_instance.this.public_ip
}
```

### Utiliser un module (main.tf)

```hcl
# Module local
module "web_server" {
  source = "./modules/ec2-instance"
  
  instance_name = "Web Server"
  instance_type = "t2.small"
}

# Module depuis le registry
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["eu-west-1a", "eu-west-1b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
}

# R√©f√©rencer les outputs d'un module
output "web_server_ip" {
  value = module.web_server.public_ip
}
```

## üíæ Le State : Le cerveau de Terraform

Le **state** est le fichier qui stocke l'√©tat de ton infrastructure.

### State local (par d√©faut)

```bash
# Fichier cr√©√© automatiquement
terraform.tfstate
```

‚ö†Ô∏è **Probl√®me** : Si plusieurs personnes travaillent, c'est le chaos !

### State distant (recommand√©)

```hcl
# backend.tf
terraform {
  backend "s3" {
    bucket         = "mon-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"  # Pour le verrouillage
  }
}
```

Avantages :
- ‚úÖ Collaboration d'√©quipe
- ‚úÖ Verrouillage (√©vite les conflits)
- ‚úÖ Historique et versioning
- ‚úÖ S√©curis√© et chiffr√©

### Commandes state

```bash
# Lister les ressources
terraform state list

# Afficher une ressource
terraform state show aws_instance.web

# Retirer une ressource du state
terraform state rm aws_instance.web

# D√©placer une ressource
terraform state mv aws_instance.old aws_instance.new

# Importer une ressource existante
terraform import aws_instance.web i-1234567890abcdef0
```

## üå©Ô∏è Exemple pratique : D√©ployer sur AWS

Cr√©ons une instance EC2 sur AWS !

### 1. Configure AWS

```bash
# Installe AWS CLI
brew install awscli

# Configure tes credentials
aws configure
```

### 2. Cr√©e le projet

**providers.tf**
```hcl
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}
```

**variables.tf**
```hcl
variable "region" {
  description = "R√©gion AWS"
  type        = string
  default     = "eu-west-1"
}

variable "instance_type" {
  description = "Type d'instance"
  type        = string
  default     = "t2.micro"
}

variable "ami_id" {
  description = "AMI Ubuntu 22.04"
  type        = string
  default     = "ami-0c55b159cbfafe1f0"  # Ubuntu 22.04 eu-west-1
}
```

**main.tf**
```hcl
# Groupe de s√©curit√©
resource "aws_security_group" "web" {
  name        = "web-sg"
  description = "Autorise HTTP et SSH"
  
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Instance EC2
resource "aws_instance" "web" {
  ami                    = var.ami_id
  instance_type          = var.instance_type
  vpc_security_group_ids = [aws_security_group.web.id]
  
  user_data = <<-EOF
              #!/bin/bash
              apt-get update
              apt-get install -y nginx
              echo "Hello from Terraform!" > /var/www/html/index.html
              systemctl start nginx
              EOF
  
  tags = {
    Name = "Terraform Web Server"
  }
}
```

**outputs.tf**
```hcl
output "instance_public_ip" {
  description = "IP publique du serveur"
  value       = aws_instance.web.public_ip
}

output "instance_url" {
  description = "URL du serveur"
  value       = "http://${aws_instance.web.public_ip}"
}
```

### 3. D√©ploie !

```bash
# Initialise
terraform init

# Planifie
terraform plan

# Applique
terraform apply

# R√©cup√®re l'IP
terraform output instance_public_ip

# Teste
curl http://<IP>
# Hello from Terraform!
```

### 4. Nettoie

```bash
terraform destroy
```

## üéØ Exemple complet : Infrastructure web

D√©ployons une stack compl√®te avec VPC, Load Balancer, Auto Scaling !

**main.tf**
```hcl
# VPC
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "my-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["eu-west-1a", "eu-west-1b", "eu-west-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = false
  
  tags = {
    Environment = "production"
  }
}

# Security Group pour ALB
resource "aws_security_group" "alb" {
  name        = "alb-sg"
  description = "Security group pour ALB"
  vpc_id      = module.vpc.vpc_id
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Security Group pour instances
resource "aws_security_group" "web" {
  name        = "web-sg"
  description = "Security group pour web servers"
  vpc_id      = module.vpc.vpc_id
  
  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.alb.id]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Launch Template
resource "aws_launch_template" "web" {
  name_prefix   = "web-"
  image_id      = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  
  vpc_security_group_ids = [aws_security_group.web.id]
  
  user_data = base64encode(<<-EOF
              #!/bin/bash
              apt-get update
              apt-get install -y nginx
              echo "Hello from $(hostname)" > /var/www/html/index.html
              systemctl start nginx
              EOF
  )
  
  tag_specifications {
    resource_type = "instance"
    tags = {
      Name = "Web Server"
    }
  }
}

# Auto Scaling Group
resource "aws_autoscaling_group" "web" {
  name                = "web-asg"
  vpc_zone_identifier = module.vpc.private_subnets
  target_group_arns   = [aws_lb_target_group.web.arn]
  health_check_type   = "ELB"
  
  min_size         = 2
  max_size         = 6
  desired_capacity = 2
  
  launch_template {
    id      = aws_launch_template.web.id
    version = "$Latest"
  }
  
  tag {
    key                 = "Name"
    value               = "Web Server"
    propagate_at_launch = true
  }
}

# Application Load Balancer
resource "aws_lb" "web" {
  name               = "web-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = module.vpc.public_subnets
}

# Target Group
resource "aws_lb_target_group" "web" {
  name     = "web-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = module.vpc.vpc_id
  
  health_check {
    enabled             = true
    healthy_threshold   = 2
    interval            = 30
    matcher             = "200"
    path                = "/"
    port                = "traffic-port"
    protocol            = "HTTP"
    timeout             = 5
    unhealthy_threshold = 2
  }
}

# Listener
resource "aws_lb_listener" "web" {
  load_balancer_arn = aws_lb.web.arn
  port              = "80"
  protocol          = "HTTP"
  
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.web.arn
  }
}
```

**outputs.tf**
```hcl
output "alb_dns_name" {
  description = "DNS du Load Balancer"
  value       = aws_lb.web.dns_name
}

output "alb_url" {
  description = "URL du Load Balancer"
  value       = "http://${aws_lb.web.dns_name}"
}
```

D√©ploie avec :

```bash
terraform init
terraform apply
```

Teste avec l'URL du Load Balancer !

## üéì Bonnes pratiques

### 1. Structure de projet

```
projet/
‚îú‚îÄ‚îÄ environments/
‚îÇ   ‚îú‚îÄ‚îÄ dev/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ terraform.tfvars
‚îÇ   ‚îú‚îÄ‚îÄ staging/
‚îÇ   ‚îî‚îÄ‚îÄ prod/
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ network/
‚îÇ   ‚îú‚îÄ‚îÄ compute/
‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îî‚îÄ‚îÄ global/
    ‚îî‚îÄ‚îÄ s3/
```

### 2. Nomme tes ressources clairement

```hcl
# ‚ùå Mauvais
resource "aws_instance" "a" { }

# ‚úÖ Bon
resource "aws_instance" "web_server_production" { }
```

### 3. Utilise des variables

```hcl
# ‚ùå Hard-coded
resource "aws_instance" "web" {
  instance_type = "t2.micro"
}

# ‚úÖ Variable
resource "aws_instance" "web" {
  instance_type = var.instance_type
}
```

### 4. Tag toutes tes ressources

```hcl
locals {
  common_tags = {
    Environment = "production"
    ManagedBy   = "Terraform"
    Project     = "MyApp"
    Team        = "DevOps"
  }
}

resource "aws_instance" "web" {
  # ...
  tags = merge(
    local.common_tags,
    {
      Name = "Web Server"
    }
  )
}
```

### 5. Utilise le .gitignore

```gitignore
# .gitignore
**/.terraform/*
*.tfstate
*.tfstate.*
crash.log
crash.*.log
*.tfvars
*.tfvars.json
override.tf
override.tf.json
*_override.tf
*_override.tf.json
.terraformrc
terraform.rc
```

### 6. Verrouille les versions

```hcl
terraform {
  required_version = ">= 1.5.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"  # Permet 5.x mais pas 6.0
    }
  }
}
```

### 7. Utilise un backend distant

```hcl
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "eu-west-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
  }
}
```

### 8. Utilise des workspaces pour les environnements

```bash
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

terraform workspace select dev
terraform apply
```

### 9. Documente ton code

```hcl
# Cr√©e un VPC avec 3 AZ pour la haute disponibilit√©
# Configure automatiquement les route tables et NAT gateways
module "vpc" {
  source = "./modules/vpc"
  # ...
}
```

### 10. Teste avec `terraform plan`

```bash
# TOUJOURS v√©rifier avant d'appliquer
terraform plan -out=plan.tfplan
terraform apply plan.tfplan
```

## üöÄ Commandes avanc√©es

### Ciblage de ressources

```bash
# Appliquer uniquement une ressource
terraform apply -target=aws_instance.web

# D√©truire uniquement une ressource
terraform destroy -target=aws_s3_bucket.data
```

### Graphe de d√©pendances

```bash
# G√©n√©rer un graphe
terraform graph | dot -Tsvg > graph.svg
```

### Debugging

```bash
# Activer les logs d√©taill√©s
export TF_LOG=DEBUG
terraform apply

# Logs dans un fichier
export TF_LOG_PATH=terraform.log
```

### Parallelism

```bash
# Limiter le nombre de ressources trait√©es en parall√®le
terraform apply -parallelism=5
```

### Refresh

```bash
# Mettre √† jour le state sans appliquer de changements
terraform refresh
```

## üöÄ Exercice pratique

**Mission** : Cr√©e une infrastructure compl√®te avec :
- Un VPC avec subnets publics et priv√©s
- Une base de donn√©es RDS PostgreSQL
- Une instance EC2 pour une API
- Un bucket S3 pour les fichiers statiques

<details>
<summary>Solution üëá</summary>

```hcl
# variables.tf
variable "region" {
  default = "eu-west-1"
}

variable "project_name" {
  default = "my-app"
}

variable "db_password" {
  type      = string
  sensitive = true
}

# main.tf
provider "aws" {
  region = var.region
}

# VPC
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "${var.project_name}-vpc"
  cidr = "10.0.0.0/16"
  
  azs              = ["${var.region}a", "${var.region}b"]
  private_subnets  = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets   = ["10.0.101.0/24", "10.0.102.0/24"]
  database_subnets = ["10.0.201.0/24", "10.0.202.0/24"]
  
  enable_nat_gateway = true
  single_nat_gateway = true
  
  create_database_subnet_group = true
}

# Security Group RDS
resource "aws_security_group" "db" {
  name        = "${var.project_name}-db-sg"
  vpc_id      = module.vpc.vpc_id
  
  ingress {
    from_port       = 5432
    to_port         = 5432
    protocol        = "tcp"
    security_groups = [aws_security_group.api.id]
  }
}

# Security Group API
resource "aws_security_group" "api" {
  name   = "${var.project_name}-api-sg"
  vpc_id = module.vpc.vpc_id
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# RDS PostgreSQL
resource "aws_db_instance" "main" {
  identifier             = "${var.project_name}-db"
  engine                 = "postgres"
  engine_version         = "15.4"
  instance_class         = "db.t3.micro"
  allocated_storage      = 20
  storage_encrypted      = true
  
  db_name  = "myapp"
  username = "admin"
  password = var.db_password
  
  db_subnet_group_name   = module.vpc.database_subnet_group_name
  vpc_security_group_ids = [aws_security_group.db.id]
  
  skip_final_snapshot = true
}

# EC2 Instance
resource "aws_instance" "api" {
  ami                    = "ami-0c55b159cbfafe1f0"
  instance_type          = "t2.micro"
  subnet_id              = module.vpc.public_subnets[0]
  vpc_security_group_ids = [aws_security_group.api.id]
  
  tags = {
    Name = "${var.project_name}-api"
  }
}

# S3 Bucket
resource "aws_s3_bucket" "static" {
  bucket = "${var.project_name}-static-${random_id.bucket_suffix.hex}"
}

resource "random_id" "bucket_suffix" {
  byte_length = 4
}

resource "aws_s3_bucket_public_access_block" "static" {
  bucket = aws_s3_bucket.static.id
  
  block_public_acls       = false
  block_public_policy     = false
  ignore_public_acls      = false
  restrict_public_buckets = false
}

# outputs.tf
output "api_public_ip" {
  value = aws_instance.api.public_ip
}

output "db_endpoint" {
  value     = aws_db_instance.main.endpoint
  sensitive = true
}

output "s3_bucket_name" {
  value = aws_s3_bucket.static.bucket
}
```

D√©ploie avec :

```bash
terraform init
terraform apply -var="db_password=SuperSecretPass123!"
```

</details>

## üî• Prochaines √©tapes

1. Apprends [Terragrunt](#) pour g√©rer plusieurs environnements
2. D√©couvre [Terraform Cloud](#) pour la collaboration
3. Explore [terraform-docs](#) pour g√©n√©rer la documentation
4. Teste [tflint](#) pour valider ton code
5. Utilise [Checkov](#) pour la s√©curit√©
6. Exp√©rimente avec [CDK for Terraform](#) (TypeScript/Python)

## üìö Ressources

- [Documentation Terraform officielle](https://www.terraform.io/docs)
- [Terraform Registry](https://registry.terraform.io)
- [Terraform Best Practices](https://www.terraform-best-practices.com)
- [Awesome Terraform](https://github.com/shuaibiyy/awesome-terraform)
- [Learn Terraform](https://learn.hashicorp.com/terraform)
- [Terraform AWS Examples](https://github.com/terraform-aws-modules)

---

**F√©licitations !** üéâ Tu sais maintenant utiliser Terraform pour g√©rer ton infrastructure as code. 
√Ä toi de d√©ployer des infrastructures complexes en quelques lignes ! ‚òÅÔ∏è

N'oublie pas : **Toujours faire un `terraform plan` avant un `apply` !** üöÄ
